/**
 * Global default options as {@link Options} that are applied to **all** mande
 * instances. Always contain an initialized `headers` property with the default
 * headers:
 * - Accept: 'application/json'
 * - 'Content-Type': 'application/json'
 */
export declare const defaults: Options & Pick<Required<Options>, 'headers' | 'responseAs'>;

declare type InferArgs<F> = F extends (api: MandeInstance, ...args: infer A) => any ? A : never;

/**
 * Create a Mande instance
 *
 * @example
 * ```js
 * const users = mande('/api/users')
 * users.get('2').then(user => {
 *   // do something
 * })
 * ```
 * @param baseURL - absolute url
 * @param instanceOptions - optional options that will be applied to every
 * other request for this instance
 */
export declare function mande(baseURL: string, passedInstanceOptions?: OptionsRaw, fetchPolyfill?: Window['fetch']): MandeInstance;

/**
 * Extended Error with the raw `Response` object.
 */
export declare interface MandeError<T = any> extends Error {
    body: T;
    response: Response;
}

/**
 * Object returned by {@link mande}
 */
export declare interface MandeInstance {
    /**
     * Writable options.
     */
    options: Required<Pick<OptionsRaw, 'headers'>> & Pick<OptionsRaw, 'responseAs' | 'query'>;
    /**
     * Sends a GET request to the given url.
     *
     * @example
     * ```js
     * users.get('2').then(user => {
     *   // do something
     * })
     * ```
     * @param url - relative url to send the request to
     * @param options - optional {@link Options}
     */
    get(url: string | number, options?: Options<'response'>): Promise<Response>;
    get(url: string | number, options?: Options<'text'>): Promise<string>;
    get<T = unknown>(url: string | number, options?: Options): Promise<T>;
    /**
     * Sends a POST request to the given url.
     *
     * @example
     * ```js
     * users.post('', { name: 'Eduardo' }).then(user => {
     *   // do something
     * })
     * ```
     * @param url - relative url to send the request to
     * @param data - optional body of the request
     * @param options - optional {@link Options}
     */
    post<T = unknown>(url: string | number, data?: any, options?: Options): Promise<T>;
    post<T = unknown>(data?: any, options?: Options): Promise<T>;
    post(url: string | number, data?: any, options?: Options<'text'>): Promise<string>;
    post(data?: any, options?: Options<'text'>): Promise<string>;
    post(url: string | number, data?: any, options?: Options<'response'>): Promise<Response>;
    post(data?: any, options?: Options<'response'>): Promise<Response>;
    /**
     * Sends a PUT request to the given url.
     *
     * @example
     * ```js
     * users.put('2', { name: 'Eduardo' }).then(user => {
     *   // do something
     * })
     * ```
     * @param url - relative url to send the request to
     * @param data - optional body of the request
     * @param options - optional {@link Options}
     */
    put<T = unknown>(url: string | number, data?: any, options?: Options): Promise<T>;
    put<T = unknown>(data?: any, options?: Options): Promise<T>;
    put(url: string | number, data?: any, options?: Options<'text'>): Promise<string>;
    put(data?: any, options?: Options<'text'>): Promise<string>;
    put(url: string | number, data?: any, options?: Options<'response'>): Promise<Response>;
    put(data?: any, options?: Options<'response'>): Promise<Response>;
    /**
     * Sends a PATCH request to the given url.
     *
     * @example
     * ```js
     * users.patch('2', { name: 'Eduardo' }).then(user => {
     *   // do something
     * })
     * ```
     * @param url - relative url to send the request to
     * @param data - optional body of the request
     * @param options - optional {@link Options}
     */
    patch<T = unknown>(url: string | number, data?: any, options?: Options): Promise<T>;
    patch<T = unknown>(data?: any, options?: Options): Promise<T>;
    patch(url: string | number, data?: any, options?: Options<'response'>): Promise<Response>;
    patch(data?: any, options?: Options<'response'>): Promise<Response>;
    patch(url: string | number, data?: any, options?: Options<'text'>): Promise<string>;
    patch(data?: any, options?: Options<'text'>): Promise<string>;
    /**
     * Sends a DELETE request to the given url.
     *
     * @example
     * ```js
     * users.delete('2').then(user => {
     *   // do something
     * })
     * ```
     * @param url - relative url to send the request to
     * @param options - optional {@link Options}
     */
    delete<T = unknown>(url: string | number, options?: Options): Promise<T>;
    delete(url: string | number, options?: Options<'response'>): Promise<Response>;
    delete(url: string | number, options?: Options<'text'>): Promise<string>;
}

/**
 * Creates an Nuxt SSR compatible function that automatically proxies cookies
 * to requests and works transparently on the server and client (it still
 * requires a fetch polyfill on Node).
 * @example
 * ```js
 * import { mande, nuxtWrap } from 'mande'
 *
 * const fetchPolyfill = process.server ? require('node-fetch') : fetch
 * const users = mande(BASE_URL + '/api/users', {}, fetchPolyfill)
 *
 * export const getUserById = nuxtWrap(users, (api, id: string) => api.get(id))
 * ```
 *
 * @param api - Mande instance to wrap
 * @param fn - function to be wrapped
 */
export declare function nuxtWrap<M extends MandeInstance, F extends (api: M, ...args: any[]) => any>(api: M, fn: F): (...args: InferArgs<F>) => ReturnType<F>;

/**
 * Allowed options for a request. Extends native `RequestInit`.
 */
export declare interface Options<ResponseAs extends ResponseAsTypes = ResponseAsTypes> extends RequestInit {
    /**
     * Optional query object. Does not support arrays. Will get stringified
     */
    query?: any;
    /**
     * What kind of response is expected. Defaults to `json`. `response` will
     * return the raw response from `fetch`.
     */
    responseAs?: ResponseAs;
    /**
     * Headers sent alongside the request
     */
    headers?: Record<string, string>;
}

export declare interface OptionsRaw<R extends ResponseAsTypes = ResponseAsTypes> extends Omit<Options<R>, 'headers' | 'signal'> {
    /**
     * Headers sent alongside the request. Set any header to null to remove it.
     */
    headers?: Record<string, string | null>;
    /**
     * AbortSignal can only be passed to requests, not to a mande instance
     * because it can only be used once.
     */
    signal?: never;
}

export declare type ResponseAsTypes = 'json' | 'text' | 'response';

export { }
